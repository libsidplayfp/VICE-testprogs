VIC 6561 - cycle exact emulation
================================
(c)2001 Andreas Matthies <andreas.matthies@gmx.net>


General
-------
First of all: I have only very small knowledge about electronical details, so
I cannot talk about bus timing, high and low phase and these things. Counting
the CPU's cycles is the lowest level I will talk about.

This paper will describe some features of VIC-20's graphic processor that are
missing in the other well know documents of Lance Ewing, Marko Mäkelä and 
others. It is based on measurements with my VIC-20 (PAL) which lead to a
cycle-exact emulation within the well known emulator suite VICE. Note that I 
haven't investigated the NTSC version of the VIC (6560) yet. Everything you
will read here is about the PAL VIC. I also want to mention Pasi 'Albert' Ojala
who provided me with lots of information and wrote these excellent demos which
motivated this work.

I wrote some small test programs to examine the features and test the emulation
which are mainly variations of Marko Mäkelä's demonstration of stable raster
routines in C=hacking #10. You can also use this document as a 'readme' for
these test programs. The programs run on an unexpanded VIC-20/PAL.

One more note: I wrote this mainly for myself not to forget all the stuff I
wrote down by hand on several pieces of paper that are hard to read and will
get lost sooner or later. But maybe others are interested as well.


Timing base
-----------
I use the TV raster register of the VIC ($9004, $9003/7) as the base for cycle
counting: The first cycle after a change of bit 7 in $9003 will be called
'cycle 0 of the rasterline n' where n is 2 * peek($9004) + peek($9003)div128.
I will only deal with CPU cycles where the 6502 reads or writes to the VIC
registers or other memory. The cycles will correspond with the cycles we will
notice in VICE within a read or store instruction. If for example
 .lda $9000
is executed in cycles 13,14,15,16 then the value of $9000 in cycle 16 will be
loaded into A. If we write a value with the instruction
 .sta $9000
in cycles 13,14,15,16 then we asume that the value is stored in cycle 17 which
is the first CPU cycle that holds the new value in $9000. This may become
clearer when we get our first real example.

The first feature I want to mention is quite trivial: If an even rasterline is
reached $9004 and $9003/7 change on the same cycle.


XPOS ($9000/0-6)
----------------
A rasterline starts (the horizontal flipflop opens) in cycle n if it hasn't
already started and n is stored to $9000 in cycle n or earlier (and $9000
doesn't change before cycle n+1). The rasterline starts 4*n pixel from the
x-origin (somewhere outside the screen).
If a rasterline doesn't start at all the y-counter isn't increased (see below).

test36864:
This program changes bit 0 of $9000 in cycle 19 and again in cycle 23 of 
rasterlines 76-91. (The corresponding store instructions are executed in cycles
15-18 and 19-22, so the store cycles are 19 and 23 as explaied above.)

If we Poke a 19 to $9000, the rasterlines don't start until cycle 18. In cycle
19 $9000 is switched to 18 and the condition to open the horizontal flipflop is
never reached. Same with 23. So the whole screen starts and ends 16 rasterlines
later. Poking 20, 21 or 24 leads to earlier or later start of the rasterlines.


YPOS ($9001)
------------
The screen starts (the vertical flipflop opens) if it hasn't already started
and from cycle 1 of an (even) rasterline 2*n to cycle 0 of rasterline 2*n+2
there exist at least one cycle where n is stored $9001. Let c be the first
cycle that fulfills the condition, then the screen starts at the first
rasterline that starts after cycle c (see XPOS for rasterline start condition).
That can be n, n+1 or n+2.

test36865-1:
This program changes bit 0 of $9001 in cycle 1 of rasterline 78 and again on
cycle 1 of rasterline 80. If we poke a 39 to $9001, the screen doesn't open
'cause in the time the rasterline can match the condition to open the screen
$9001 switches to 38 which is already passed.

test36865-2:
This program is identical except that the first change happens one cycle
earlier. The screen opens even if we poke 39 into $9001 'cause it switches to
38 in cycle 0 of rasterline 78 which is the very last cycle to open the screen
here. So this program is a proof for the later border of the matching interval.

test36865-2:
... has to be rewritten to prove the early border of matching intervall...


COLUMNS ($9002/0-6)
-------------------
A rasterline has a length of n columns, if n is stored to $9002/0-6 in cycle 1
of this rasterline or earlier (and $9002/0-6 isn't changed before cycle 2).

Note that y-counter is increased even if columns is 0 (see below), so a 
rasterline with 0 columns behaves different from a rasterline that doesn't
start.

test36866-1:
This program decreases $9002 by four at cycle 19 and increases it by four to
the original value at cycle 1 of the following line. This happens at
rasterlines 76-91. The screen display is normal cause the return to the
original value at cycle 1 is early enough.

test36866-2:
This program is almost identical but increases $9002 by four one cycle later
which is cycle 2 of the rasterline and two late. So the rasterlines 77-92
display only 18 columns.

So these programs prove that the VIC reads the number of columns for each
rasterline after cycle 1.


ROWS ($9003/1-6)
----------------
The number of rows of a frame is determined after cycle 2 of rasterline 0. If
we store n to bit 1-6 of $9003 not later than cycle 2 of rasterline 0, the
following frame will display n rows (each with 8 or 16 rasterlines and one
additional if XPOS is 0.

test36867-1:
This program decreases ROWS by 16 at cycle 3 of rasterline 0 and increases it
by 16 to the original value some cycles later. The screen displays 23 rows as
usual cause ROWS is decreased one cycle too late.

test36867-2:
This program is almost identical but decreases ROWS one cycle earlier at cycle
2 of rasterline 0. So the screen displays only seven rows.


Memory fetch 
------------
This part also handles SCREENPTR ($9005/4-7, $9002/7), CHARPTR($9005/0-3),
AUXCOL ($900e/4-7), BACKCOL ($900f/4-7) and BORDERCOL	($900f/0-2).
Let's see what happens to display a character that starts at pixel x which is
4*XPOS + 8*X where X is the column of the character (starting with 0). First
the VIC reads the screen memory and the color memory. This happens after CPU
cycle (XPOS + 2*X) +  3 of each rasterline that covers the char. After the
following cycle (XPOS + 2*X) + 4 the character memory is read (uses y-counter
modulo CHARHEIGHT as offset, see below). The following two cycles are spent to
draw this character (and his background).
From a store instructions point of view we can conclude the following:
If we store a new value to SCREENPTR in cycle c, this is first visible in
column (c - XPOS - 3) div 2 (again starting with column 0).
If we store a new value to CHARPTR in cycle c, this is first visible in
column (c - XPOS - 4) div 2.
If we store a new value to AUXCOL, BACKCOL or BORDERCOL in cycle c, this is
first visible at pixel 4*(c-7).

testmemfetch-1:
This program changes SCREENPTR on cycle 19 and cycle 23 of rasterlines 76-91.
This results in unusual characters in two columns. These columns depend on the
value of XPOS. For XPOS=15..16 the unusual chars are in column 0 and 1.

testmemfetch-2:
This program changes CHARPTR on cycle 19 and cycle 23 of rasterlines 76-91.
This results in unusual characters in two columns. These columns depend on the
value of XPOS. For XPOS=14..15 the unusual chars are in column 0 and 1.

testback:
This is Marko's original raster routine. It proves the formular for BACKCOL and
BORDERCOL. (And believe me: AUXCOL and BORDERCOL behave the same way.)
BACKCOL and BORDERCOL changes on cycles 19,23,27... which results in display
changes at pixel 48,64,80...


CHARHEIGHT ($9003/0)
--------------------
Let us asume CHARHEIGHT is 8 or 16. In conjunction with CHARHEIGHT we have to
discuss the following functions of the VIC:
- "memory-pointer" that acts as an offset to SCREENPTR and points to the first
character of the current row.
- "row-counter" that is used to check if ROWS is reached and the vertical
flipflop should close.
- "y-counter" that is used to count the rasterlines within the current row. It
is increased when a rasterline is finished (see remarks at XPOS and COLUMNS).
y-counter is a 4-bit-counter although only 3 bits are used (e.g. as offset for
the character memory fetch) while CHAIRHEIGHT is 8.

The VIC checks after CPU cycle 0 of a rasterline if the row counter has to be
increased. For this it checks if ycounter is CHARHEIGHT or 2*CHARHEIGHT (which
might happen if CHARHEIGHT is set to 8 while y-counter is somewhat above 9).
In that case y-counter is reset to 0, the row-counter is increased by one and
the memory-pointer is increased by COLUMNS.

On the other hand the memory-pointer behaves someway independent from the
row-counter. If a character in column X is completely displayed (e.g. the
CHARHEIGHT=8 and y-counter=7 while fetching the character memory) the
memory-pointer will at least be increased by X+1. This can lead to the
situation that memory-pointer is increased by a value different from COLUMNS if
CHARHEIGHT changes from 8 to 16 within a rasterline with y-counter=7.

testcharheigh-1:
This program changes CHARHEIGHT at cycle 20 of rasterline 83 (y-counter=7) and
back at cycle 0 of rasterline 84. ROWS is 8.
In the first screen CHARHEIGHT changes from 8 to 16 back to 8. The last change
is early enough, so we get 8 rows with height 8.  The underline in row 1 shows
that a change of CHARHEIGHT immediately influences the character memory fetch.
In the later screen CHARHEIGHT changes from 16 to 8 back to 16. We get 8 rows
with height 16 as expected.

testcharheigh-2:
This program again changes CHARHEIGHT at cycle 20 of rasterline 83 but changes
it back one cycle later at cycle 1 of rasterline 84. So in the first screen
(8->16->8) the row counter doesn't increase here and we get 1*16+7*8=72
rasterlines. The memory-pointer is only increased by the number of characters
up to the last one displayed completely which is 2.
In the later screen (16->8->16) the row-counter is increased in rasterline 84
cause CHARHEIGHT is still 8. So the screen displays 1*8+7*16=248 rasterlines.


REVERSE ($900f/3)
-----------------
Just the short note that a change in the REVERSE bit is first visible at pixel
4*(c-7) + 3 (which isn't a multiple of 4 like every other effect).
