 .word $0801

; *** Symbol table  follows ***

 sstart     = $8000
 sstop      = $9000

 zINDEX        = $22
 zFREKZP       = $FB
 vControl      = $D011
 vSprEnable    = $D015
 sVoc3FreqLo   = $D40E
 sVoc3FreqHi   = $D40F
 sVoc3PWidthLo = $D410
 sVoc3PWidthHi = $D411
 sVoc3Control  = $D412
 sVoc3Osc      = $D41B
 kSETLFS       = $FFBA
 kSETNAM       = $FFBD
 kSAVE         = $FFD8

; *** text follows ***

    * = $0801
    .byte $0b,$08,$01,$00,$9e,$32,$30,$36,$31,$00,$00,$00
    jmp start
        
    .dsb $1000 - *, 0

 *=$1000
start

	; We miss the first four cycles of the sample (three cycles for
	; MOS8580), so we blank the first four bytes.
	LDA #$00
	STA sstart
	STA sstart+1
	STA sstart+2
	STA sstart+3

	; Detect SID model.
	JSR disable
	JSR sidver
	STA model
	JSR enable

	LDX #$00
	; Select waveform
nxtfile	LDA waves,X
	STA curwave
	TXA	
	PHA	

	; Generate and run sampling code
	JSR disable
	JSR genrun
	JSR enable

	; Set up logical file
	LDA #$01
	LDX #$08
	LDY #$00
	JSR kSETLFS

	; Get index and multiply with number of chars in file name (12).
	PLA
	PHA
	ASL
	ASL
	STA zINDEX
	ASL
	ADC zINDEX

	; Add offset for MOS8580 file names.
	LDX model
	BNE oldsid
	CLC
	ADC #8*12
oldsid
	; Set up file name
	CLC
	ADC #<files65
	TAX
	LDA #$00
	ADC #>files65
	TAY
	LDA #12
	JSR kSETNAM

	; Save sample data sstart-sstop
	LDA #<sstart
	STA zINDEX
	LDA #>sstart
	STA zINDEX+1
	LDX #<sstop
	LDY #>sstop
	LDA #zINDEX
	JSR kSAVE

	PLA	
	TAX	
	INX	
	CPX #$08
	BNE nxtfile
	RTS	

; Waveforms
waves	.byte $10, $20, $30, $40, $50, $60, $70, $80

; File names
files65	.asc "6581WF10.DAT"
	.asc "6581WF20.DAT"
	.asc "6581WF30.DAT"
	.asc "6581WF40.DAT"
	.asc "6581WF50.DAT"
	.asc "6581WF60.DAT"
	.asc "6581WF70.DAT"
	.asc "6581WF80.DAT"
files85	.asc "8580WF10.DAT"
	.asc "8580WF20.DAT"
	.asc "8580WF30.DAT"
	.asc "8580WF40.DAT"
	.asc "8580WF50.DAT"
	.asc "8580WF60.DAT"
	.asc "8580WF70.DAT"
	.asc "8580WF80.DAT"

; Current waveform
curwave .byte $00

; SID chip model
model	.byte $00

; Generate and run sampling code.
genrun	LDA #<scode
	STA zINDEX
	LDA #>scode
	STA zINDEX+1

	; X holds code offset, Y holds sample offset
	LDX #$00
	LDY #$00
	JSR gencode

	; no delay
	JSR sample

	LDX #$00
	LDY #$01
	JSR gencode

	; lda $d3f0,x (one cycle delay)
	LDY #$00
	LDA #$BD
	STA (zINDEX),Y
	INY	
	LDA #$F0
	STA (zINDEX),Y
	INY	
	LDA #$D3
	STA (zINDEX),Y
	; Offset for lda,x
	LDX #$2B
	JSR sample

	LDX #$01
	LDY #$02
	JSR gencode

	; nop (two cycle delay)
	LDY #$00
	LDA #$EA
	STA (zINDEX),Y
	JSR sample

	LDX #$02
	LDY #$03
	JSR gencode

	; bit $ff (three cycle delay)
	LDY #$00
	LDA #$24
	STA (zINDEX),Y
	INY	
	LDA #$FF
	STA (zINDEX),Y
	JSR sample

	LDX #$02
	LDY #$04
	JSR gencode

	; nop nop (four cycle delay)
	LDY #$00
	LDA #$EA
	STA (zINDEX),Y
	INY	
	LDA #$EA
	STA (zINDEX),Y
	JSR sample

	LDX #$02
	LDY #$05
	JSR gencode

	; asl $ff (five cycle delay)
	LDY #$00
	LDA #$06
	STA (zINDEX),Y
	INY	
	LDA #$FF
	STA (zINDEX),Y
	JSR sample

	LDX #$02
	LDY #$06
	JSR gencode

	; asl $ff,x (six cycle delay)
	LDY #$00
	LDA #$16
	STA (zINDEX),Y
	INY	
	LDA #$FF
	STA (zINDEX),Y
	; Offset for asl,x
	LDX #$00
	JSR sample

	LDX #$03
	LDY #$07
	JSR gencode

	; asl $00ff,x (seven cycle delay)
	LDY #$00
	LDA #$1E
	STA (zINDEX),Y
	INY	
	LDA #$FF
	STA (zINDEX),Y
	INY	
	LDA #$00
	STA (zINDEX),Y
	; Offset for asl,x
	LDX #$00
	JSR sample

	RTS	

; Generate code on the form
; LDA $D41B
; STA $8004
; LDA $D41B
; STA $800C
; ...
gencode	TXA	
	CLC	
	ADC zINDEX
	STA zFREKZP
	LDA #$00
	ADC zINDEX+1
	STA zFREKZP+1
	TYA	
	CLC

	; Add three cycles for MOS8580, four cycles for MOS6581.
	ADC #$03
	ADC model
	ADC #<sstart
	STA zFREKZP+2
	LDA #$00
	ADC #>sstart
	STA zFREKZP+3
nxtinst	LDY #$00

	; lda $d41b
	LDA #$AD
	STA (zFREKZP),Y
	INY	
	LDA #$1B
	STA (zFREKZP),Y
	INY	
	LDA #$D4
	STA (zFREKZP),Y
	INY	

	; sta $xxxx
	LDA #$8D
	STA (zFREKZP),Y
	INY	
	LDA zFREKZP+2
	STA (zFREKZP),Y
	INY	
	LDA zFREKZP+3
	STA (zFREKZP),Y

	INY	
	TYA	
	CLC	
	ADC zFREKZP
	STA zFREKZP
	LDA #$00
	ADC zFREKZP+1
	STA zFREKZP+1
	LDA #$08
	CLC	
	ADC zFREKZP+2
	STA zFREKZP+2
	LDA #$00
	ADC zFREKZP+3
	STA zFREKZP+3
	SEC
	LDA zFREKZP+2
	SBC #<sstop
	LDA zFREKZP+3
	SBC #>sstop
	BCC nxtinst
	LDY #$00

	; rts
	LDA #$60
	STA (zFREKZP),Y
	RTS	

disable	SEI	
	LDA #$00
	STA vSprEnable
	LDA vControl
	AND #$EF
	STA vControl
vblank	; Wait for vblank (raster = 0)
raslo	BIT vControl
	BPL raslo
rashi	BIT vControl
	BMI rashi
	RTS	

enable	LDA vControl
	ORA #$10
	STA vControl
	CLI	
	RTS	

sidver	LDA #$08
	STA sVoc3Control
	LDA #$00
	STA sVoc3FreqLo
	LDA #$40
	STA sVoc3FreqHi
	LDA #$20
	STA sVoc3Control
	LDA sVoc3Osc
	; 1 = 6581, 0 = 8580
	; The MOS8580 waveform is delayed one cycle.
	RTS

sample	LDA #$08
	STA sVoc3Control
	LDA #$00
	STA sVoc3FreqLo
	LDA #$10
	STA sVoc3FreqHi
	LDA #$00
	STA sVoc3PWidthLo
	LDA #$00
	STA sVoc3PWidthHi
	LDA curwave
	CMP #$80
	BNE gate
	; Allow the shift register to clear (takes $2000-$4000 cycles).
	; We wait at least one frame (one frame = 19656 cycles).
	JSR vblank
	JSR vblank
gate	STA sVoc3Control

scode	.byte $00
