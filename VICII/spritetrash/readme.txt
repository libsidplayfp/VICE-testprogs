
see https://www.lemon64.com/forum/viewtopic.php?p=985974

-------------------------------------------------------------------------------

"Normally, on a PAL machine, if you put a sprite at X-position $164 or further
to the right the sprite will be shifted up by 1 pixel and the first line of the
sprite will contain garbage (well, actually whatever is on the internal data bus
on the VIC chip, which is mostly either $ff or the contents of $3fff)

But I noticed that on a 6569R1 something weird occurs at X-position $163. The
sprite is displayed normally but there is also the added garbage line, but
shifted 1 pixel to the right. So in this case the sprite actually is 22 pixels
high (!?)

Then if I move it to $162 (or further the the left) it looks all right.

This additional row at X=$163, is this a known phenomenon for the 6569R1?
I have not seen this on newer VIC-II revisions."

-------------------------------------------------------------------------------

"The top pattern for sprites past $164 appears to be

1 byte $ff (*)
1 byte contents of $3fff
1 byte $ff (*)

(*) unless the CPU was updating a VIC-II register at the same time, in which
case the value will be whatever is written into that register

Which makes sense since the sprite access pattern is

fetch sprite pointer during PHI0 low
fetch sprite byte 0 during PHI0 high <- at this point the data bus is disconnected as the CPU has the bus now
fetch sprite byte 1 during PHI0 low
fetch sprite byte 2 during PHI0 high

Interesting to note that the VIC-II always fills all sprite shift registers on
each line even if no sprite is actually active. I guess it was cheaper to do it
this way, in terms of transistors on chip."

-------------------------------------------------------------------------------

"Some ideas as to how this might work. See pictures below. This is based on the
 6569R1 die shot at http://mail.lipsia.de/~enigma/neu/6581.html

The sprite shifter is turned on when two conditions are satisfied:

- X coordinate of the sprite is equal to the value of the horizontal counter ("Xc")
- the sprite is active

The latter condition is evaluated for all sprites at the same time at X=$164. It
will either set or reset an SR-latch, indicated by "Y" in the picture.

Note that Y is essentially generated by an entirely different component on the chip.

There are two internal clock signals that run at 8MHz, φ1 and φ2. These are non-
overlapping, so you have something like

φ1 high, φ2 low;
φ1 low, φ2 low;
φ1 low, φ2 high;
φ1 low, φ2 low;
etc

The φ1 clock goes high whenever the X counter is increased.

The Xc comparator is buffered by φ2, so if the sprite's X register was $163,
there is window of time when the buffered value will be high even when X becomes
$164. Now if Y becomes high during the same time, this will set a latch ("X latch")
that will in turn trigger the shifter when φ1 next goes high. The shifter is also
controlled by a binary counter that is controlled by the horizontal expand bit
("SEXX") but that is not relevant here. There is also a reset line ("R") to
eventually turn the shifter off, but that is also not relevent right now.

So what I guess happens is:

on later VIC models, the Y latch never goes high during φ1, only during the next
φ2 high, in which case the Xc is back off, including the buffered output, so the
X latch is never set. That would explain why there is no garbage line on the top
of sprites when X=$163, even though in theory there should be one.

Now on the 6561R1 the Y latch appears to become high slightly earlier, where φ1
is low, but φ2 is also still low. So the X latch will be set, but the output will
not be fed yet into the shifter. So on the 6561R1 there is a garbage row but
shifted 1 pixel to the right."

-------------------------------------------------------------------------------

spritetrash.prg:

The test program basically moves one dot from left to right across a sprite,
then updates the top of the display to 'zoom in' as it were using the sprite
collision register.

The color ram is set to white because otherwise it would not be visible on v2
Kernals.

on 6569R1 this will display two 8-character wide bars in the top row
with the contents of $3fff between them

..********...**...******
000000001111111122222222
